<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1251">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.1  (Win32)">
	<META NAME="CREATED" CONTENT="20070802;12303200">
	<META NAME="CHANGED" CONTENT="20090610;15234000">
</HEAD>
<BODY LANG="ru-RU" TEXT="#000000" DIR="LTR">
<DL>
	<DT><FONT FACE="Arial, sans-serif"><FONT SIZE=4><B>Инструкция по
	работе с библиотекой LComp/WLComp) и платами/модулями L-Card в среде
	LabView.</B></FONT></FONT><DT>
	<BR>
	<DT><BR>
	<DT><FONT SIZE=2>Где лежит:</FONT><DT>
	<FONT SIZE=2>..\Library\WLCOMP &ndash; бибблиотека обертка</FONT><DT>
	<FONT SIZE=2>..\Library\WLCOMP_LV &ndash; пример и этот файл</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Для работы в среде LabView с платами L-Card
	написана библиотека-обертка WLCOMP. Она предоставляет простой С
	интерфейс к функциям библиотеки LComp. Для управления платами L-Card
	в Labview есть несколько инструментов: CallLibraryFunction, CIN.
	CallLibraryFunction просто позволяет вызвать любую функцию из
	внешней DLL библиотеки. CIN более мощный инструмент т.к. позволяет
	написать кусок С кода для вызова функции или выполнения какого-либо
	алгоритма. CIN сложнее в использовании т.к. требует наличия
	компилятора С и навыков программирования.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Итак для полноценной работы с платами L-Card хорошо
	иметь:</FONT><DT>
	<FONT SIZE=2>-LabView <SPAN LANG="en-US">8.0 </SPAN><SPAN LANG="ru-RU">и
	выше</SPAN></FONT><DT>
	<FONT SIZE=2>-Microsoft Visual C++ (например Express Edition)</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Чтобы собирать CIN из исходных тестов надо
	прописать в системе переменную CINTOOLSDIR с указанием пути на
	каталог \CINTOOLS в папке с установленным LabView. Тогда запуская
	nmake из консольного окна VC можно будет собирать CIN.В файле
	ntlvsb.mak из папки CINTOOLS можно добавить ключи компилятора по
	желанию... Я добавлял /MT для компилятора и /NODEFAULTLIB:MSVCRT для
	линкера.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Далее рассмотрим вариант подключения плат L-CARD на
	основе примера WLCOMP_LV. Этот пример использует оба
	инструмента(CIN, CallLibraryFunction) для работы с библиотекой
	WLCOMP. В принципе используя CIN можно работать и напрямую с LComp,
	но это неудобно(вызывать С++ функции из С).</FONT><DT>
	<FONT SIZE=2>Пример прост:</FONT></DL>
<UL>
	<LI>
	<FONT SIZE=2>открытие устройства</FONT></UL>
<UL>
	<LI><FONT SIZE=2>получение информации о слоте и типе платы</FONT><LI>
	<FONT SIZE=2>загрузка платы</FONT><LI>
	<FONT SIZE=2>чтение флеша</FONT><LI>
	<FONT SIZE=2>задание параметров сбора данных</FONT><LI>
	<FONT SIZE=2>выделение памяти под буфер данных</FONT><LI>
	<FONT SIZE=2>запуск сбора данных</FONT><LI>
	<FONT SIZE=2>ожидание нужного количества данных</FONT><LI>
	<FONT SIZE=2>остановка сбора</FONT><LI>
	<FONT SIZE=2>отображение данных и переход опять на запуск</FONT><LI>
	<FONT SIZE=2>по кнопке стоп выгрузка библиотеки и остановка
	программы</FONT></UL>
<DL>
	<DT><BR>
	<DT><FONT SIZE=2>Поскольку во многих функциях в качестве параметров
	используются структуры данных, то для удобства передачи параметров
	как раз и используется CIN. В более простых функциях используется
	CallLibraryFunction. Пример расчитан на работу с платами L761 L780
	L783 <SPAN LANG="en-US">L791 E154 </SPAN>E14-440 E14-140 E20-10.
	Перед запуском поэтому необходимо указать специфичные для плат
	параметры: слот, имя биоса без расширения, константу синхронизации.
	Пример собирает данные с четырех каналов платы (0123) и на
	максимальной частоте (на модуле 20-10 на частоте 1Мгц, на остальных
	происходит фактически округление в библиотеке). </FONT>
	<DT><BR>
	<DT><FONT SIZE=2>Исходные коды всех CIN прилагаются. Внутри каждого
	CIN определяется тип платы и происходит ветвление при передаче
	структур в функцию библиотеки.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>При заполнении кластера с параметрами сбора данных
	число 7680 это просто численное значение SIG_0|SIG_1|SIG_2|SIG_3 для
	платы E20-10.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>При работе с платами которым не нужен биос нужно
	указать произвольный файл. Просто функция загрузки вернет статус &ndash;
	ошибка L_NOTSUPPORTED.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Некоторые пояснения по CIN</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>CIN GetSlotParam</FONT><DT>
	<FONT SIZE=2>Поскольку структура SLOT_PARAM простая и состоит из
	однотипных переменных то тут она передается как массив. В принципе
	можно было просто функцию вызвать и без CIN.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>CIN ReadPlataDescr</FONT><DT>
	<FONT SIZE=2>Тут все гораздо сложнее т.к. структуры для разных
	модулей разные. Поэтому формируется кластер с нужными полями и
	передается внутрь CIN где происходит ветвление по типу плат.
	Собственно говоря, можно просто флеш прочитать, а данные никакие не
	возвращать т.к. все прочитанное храниться внутри объекта и
	используется при расчетах.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>CIN FillDAQParameters </FONT>
	<DT><FONT SIZE=2>Тоже сложный CIN. Внутри выбирает в зависимости от
	платы структуру для описания параметров сбора данных. А в структуре
	данных еще кодируется ЦАП или АЦП.... Формируется кластер вполне
	универсально, а вот внутри трактовка полей различна....Учитывая
	универсальность примера параметры сбора заданы специфически, так
	чтобы удовлетворять всем платам.</FONT><DT>
	<FONT SIZE=2>Порядок заполнения полей структуры из полей кластера см
	исходный код CIN.</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Перед началом сбора данных есть большой CASE &ndash;
	он собственно служит для подстройки цикла сбора данных под разные
	платы... В частности задает адрес с которого читать переменную Sync,
	размер отсчета в байтах и битовую маску которая накладывается на
	данные. Это может понадобиться для платы L791...</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Абсолютные значения различных констант нужно
	смотреть в файле ioctl.h</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>В папке <SPAN LANG="en-US">WLCOMP_LV_SE </SPAN>добавлен
	пример работы с <SPAN LANG="en-US">NI SignalExpress 3.0. </SPAN>В
	этом примере используется метод вызова <SPAN LANG="en-US">LabView VI
	</SPAN>файла в проекте <SPAN LANG="en-US">SignalExpress. VI
	</SPAN>построена на базе примера <SPAN LANG="en-US">WLCOMP</SPAN>_<SPAN LANG="en-US">LV
	</SPAN>плюс заготовка из <SPAN LANG="en-US">SignalExpress
	UserDefinedStepTemplate.vi. </SPAN>Это все согласно иструкциям <SPAN LANG="en-US">NI
	</SPAN>упаковано в <SPAN LANG="en-US">LLB </SPAN>библиотеку
	<SPAN LANG="en-US">mystep.llb, </SPAN>которая собственно говоря и
	подключается в проект <SPAN LANG="en-US">SignalExpress. 
	</SPAN>Используемые средства &mdash; <SPAN LANG="en-US">LabView 8.5
	</SPAN>и <SPAN LANG="en-US">SignalExpress 3.0.</SPAN></FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Для упрощения кода <SPAN LANG="en-US">LabView
	</SPAN>примеров в библиотеку <SPAN LANG="en-US">lcomp </SPAN>добавлены
	пользовательские переменные <SPAN LANG="en-US">(ULONG, 128</SPAN>
	штук) которые можно читать-писать посредством вызова
	<SPAN LANG="en-US">Get|SetParameters (</SPAN>аля проперти<SPAN LANG="en-US">).</SPAN></FONT><DT>
	<FONT SIZE=2>В <SPAN LANG="en-US">ioctl.h </SPAN>внесены определения</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>//defines for GetParemeter/SetParameter common for
	all boards</FONT><DT>
	<FONT SIZE=2>#define L_BOARD_TYPE 		10000</FONT><DT>
	<FONT SIZE=2>#define L_POINT_SIZE 		10001</FONT><DT>
	<FONT SIZE=2>#define L_SYNC_ADDR_LO     10002</FONT><DT>
	<FONT SIZE=2>#define L_SYNC_ADDR_HI     10003</FONT><DT>
	<FONT SIZE=2>#define L_DATA_ADDR_LO		10004</FONT><DT>
	<FONT SIZE=2>#define L_DATA_ADDR_HI		10005</FONT><DT>
	<FONT SIZE=2>#define L_SYNC1_ADDR_LO     10006</FONT><DT>
	<FONT SIZE=2>#define L_SYNC1_ADDR_HI     10007</FONT><DT>
	<FONT SIZE=2>#define L_DATA1_ADDR_LO		10008</FONT><DT>
	<FONT SIZE=2>#define L_DATA1_ADDR_HI		10009</FONT><DT>
	<BR>
	<DT><BR>
	<DT><FONT SIZE=2>#define L_USER_BASE        10100 // 128 user
	prpoperty to store data</FONT><DT>
	<BR>
	<DT><FONT SIZE=2>Есть предопределенные проперти: тип платы, размер
	отсчета в байтах, адреса буферов и счетчиков.</FONT><DT>
	<FONT SIZE=2>Как это все задействовано см. пример.</FONT><DT>
	<BR>
	<DT><BR>
	<DT><BR>
	<DT><FONT SIZE=2>Собственно говоря все....</FONT></DL>
</BODY>
</HTML>